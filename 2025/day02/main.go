package main

import (
	"bufio"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
)

func nemLen(i int) int {
	if i < 10 {
		return 1
	} else if i < 100 {
		return 2
	} else if i < 1000 {
		return 3
	} else if i < 10000 {
		return 4
	} else if i < 100000 {
		return 5
	} else if i < 1000000 {
		return 6
	} else if i < 10000000 {
		return 7
	} else if i < 100000000 {
		return 8
	} else if i < 1000000000 {
		return 9
	} else if i < 10000000000 {
		return 10
	}
	panic("too big")
}

func pow10(i int) int {
	if i == 1 {
		return 10
	}
	if i == 2 {
		return 100
	}
	if i == 3 {
		return 1000
	}
	if i == 4 {
		return 10000
	}
	if i == 5 {
		return 100000
	}
	if i == 6 {
		return 1000000
	}
	if i == 7 {
		return 10000000
	}
	if i == 8 {
		return 100000000
	}
	if i == 9 {
		return 1000000000
	}
	if i == 10 {
		return 10000000000
	}
	panic("too big")
}

func fs1(input io.Reader) int {
	scanner := bufio.NewScanner(input)
	invalidSum := 0
	for scanner.Scan() {
		line := scanner.Text()
		ranges := strings.Split(line, ",")
		for _, r := range ranges {
			s := strings.Split(r, "-")
			from, _ := strconv.Atoi(s[0])
			to, _ := strconv.Atoi(s[1])
			for check := from; check <= to; check++ {
				if nemLen(check)%2 != 0 {
					continue
				}
				divi := nemLen(check) / 2
				left := check / pow10(divi)
				right := check % pow10(divi)
				if left == right {
					invalidSum += check
				}
			}
		}
	}
	return invalidSum
}

func fs2(input io.Reader) int {
	scanner := bufio.NewScanner(input)
	invalidSum := 0
	for scanner.Scan() {
		line := scanner.Text()
		ranges := strings.Split(line, ",")
		for _, r := range ranges {
			s := strings.Split(r, "-")
			from, _ := strconv.Atoi(s[0])
			to, _ := strconv.Atoi(s[1])
			for check := from; check <= to; check++ {
				l := nemLen(check)
				for divider := 1; divider < l; divider++ {
					if l%divider != 0 { //if the length is not divisible, it cannot be generated by repetition
						continue
					}
					leftch := check / pow10(l-divider) // left part that supposed to be repeated
					testch := 0
					for i := 0; i < l/divider; i++ { //generate repeated number
						testch *= pow10(divider)
						testch += leftch
					}
					if testch != check {
						continue
					}
					invalidSum += check
					break //if we find match, no need to check other repetitions
				}
			}
		}
	}
	return invalidSum
}

func main() {
	f, err := os.Open("test.txt")
	if err != nil {
		log.Fatal(err)
	}
	fs2(f)
}
